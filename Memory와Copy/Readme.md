# Memory와 Copy

## 파이썬 메모리 구조
- 코드 영역 : 실행할 프로그램의 코드가 저장됩니다. CPU는 텍스트 영역에 저장된 명령어를 하나씩 가져가서 처리합니다.
- Data 영역 : 전역변수와 정적변수를 저장하는 공간이며, 프로그램 시작과 할당되며, 프로그램이 종료되면 소멸됩니다.
- Stack 영역 : 지역 변수와 매개변수를 저장하는 공간이며, 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸됩니다.
- Heap 영역 : 사용자의 동적 할당으로 생성되는 공간이며, 사용자가 공간의 크기를 직접 관리할 수 있습니다.

```py
a = 10
b = a
print(a,b) # 10 10

a += 1
print(a,b) # 11 10

A = [10,20,30]

B = A
print(A,B) #예상 : [10,20,30] [10,20,30]

[10, 20, 30] [10, 20, 30]

A[0] += 1
print(A,B) #예상 : [11,20,30] [10,20,30] -> aliasing

[11, 20, 30] [11, 20, 30]
```
## Mutable & Immutable
- 파이썬은 모든 것이 객체(Object)인데, 그 속성이 mutable(값이 변한다)과 immutable로 구분된다.
  - Immutable : 정수, 문자열, 튜플
      - 값을 전달할 때 Call By Value의 속성을 띄고 있다.
      - 값을 바꾸면 메모리 주소를 새롭게 할당을 받는다.
  - Mutable : list, Dictionary
      - 값을 전달할 때 Call By Reference 속성을 띄고 있다.
      - 값을 바꾸더라도 메모리 주소가 바뀌지 않는다.

## aliasing
- 두 변수가 가리키는 메모리 주소가 같으면 서로의 '엘리어싱(Aliasing)'이라고 한다.
- 문자열 처럼 그 자체의 값이 변경 불가능한 값은 엘리어스를 생성해도 안전하지만,
- 리스트(list)같은 가변적인 값은 엘리어스를 생성하게 되면 프로그램의 흐름에 문제가 생길 수 있다.

```py
a = 10
b = a
print(id(a),id(b)) # id : 메모리 주소 값 확인

1754257582672 1754257582672

a += 1
print(id(a),id(b)) # 다른 메모리 주소로 변경

1754257582704 1754257582672

A = [10,20,30]
B = A
print(id(A),id(B))

1754343384896 1754343384896

A[0] += 1
print(id(A),id(B)) # 동일한 메모리 주소

1754343384896 1754343384896
```

## Assignment vs Shallow Copy vs Deep Copy
- 대입연산 vs 얕은 복사 vs 깊은 복사

### 대입연산(Assignment)
- 대입연산과 복사는 다르다.
```py
a = 20
b = a
print(a == b) #동일한 값인지 비교
print( a is b) #동일한 객체인지 비교 -> id(), 주소값을 가지고 동일한 객체인지 비교합니다

True
True

a+=1 # a = 21, b = 20
print(a == b)
print(a is b)

False
False

# is와 ==
print(0 == 0.0) # True 값은 같으니까
print(0 is 0.0) # False 메모리 주소가 다르니까

True
False
```
- 대입연산자를 사용했더니 정수형은 값을 대입해서 더한다던지 하면 동일한 객체가 아니라고 뜨고
- 리스트 같은 경우 첫번째 인덱스의 값을 증가시켜줘도 동일한 객체다.

### 얕은 복사(Shallow Copy)
- 새로운 객체를 만들고 객체의 값만 복사

### list의 얕은 복사 방법
1. copy() 함수 사용
```py
x = [10,20,30]
y1 = x #대입
y2 = x.copy() #얕은 복사 -> 값만 복사하여 새로운 객체를 만든다.
print(x, y1, y2)
print(x == y1 == y2)
print(id(x),id(y1),id(y2))

[10, 20, 30] [10, 20, 30] [10, 20, 30]

True

1754371419136 1754371419136 1754371247552

x[0] = 100
print(x, y1, y2)

[100, 20, 30] [100, 20, 30] [10, 20, 30]
```
2. 범위 지정 [:] 사용
```py
x = [10,20,30]
y1 = x
y2 = x[:] #x의 처음부터 끝까지 얕은 복사 발생(리스트에 한정해서 발생)
print(id(x),id(y1),id(y2))

1754371725888 1754371725888 1754371699520
```
3. list()함수 사용
```py
x = [10,20,30]
y1 = x
y2 = list(x)
print(id(x),id(y1),id(y2))

1754371954752 1754371954752 1754360122240
```
4. copy.copy() 사용
```py
import copy
x = [10,20,30]
y1 = x
y2 = copy.copy(x)
print(id(x),id(y1),id(y2))

1754372117376 1754372117376 1754372122368
```
### 얕은 복사의 한계
```py
x = [1,2,['A','B','C']]
y = x[:]
print(x,y)
print(x == y, x is y) #x 와 y는 다른 객체다
print(x[2] is y[2]) #동일한 객체 -> 리스트 안에 있는 리스트는 얕은 복사를 하더라도 리스트의 주소값이 복사됨

[1, 2, ['A', 'B', 'C']] [1, 2, ['A', 'B', 'C']]
True False
True

x[0] = 100
print(x,y)
x[2][2] = 'c'
print(x,y)

[100, 2, ['A', 'B', 'C']] [1, 2, ['A', 'B', 'C']]
[100, 2, ['A', 'B', 'c']] [1, 2, ['A', 'B', 'c']]
```
- 다중 리스트의 경우 얕은복사로는 완전히 복사를 할 수가 없다.

### 깊은복사(Deep Copy)
```py
import copy
x = [1,2,['A','B','C']]
y = copy.deepcopy(x)

print( x is y)
print(x[2] is y[2])
x[2][2] = 'c'
print(x,y)

False
False
[1, 2, ['A', 'B', 'c']] [1, 2, ['A', 'B', 'C']]
```
